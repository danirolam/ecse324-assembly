
2025-FALL / ECSE-324-001
Captions
Search current recording by keyword
Brett Meyer, Prof: So, last time, Last time, I forgot that I had asked ChatGPT about Indian myth. I said. In the chat box. briefly explain the difference between Big Andean and Little Indian, which is more commonly used today. Can any of you answer this question? Yes. So, Will H is definitely the second… the answer to the second question. It is the most commonly used one to say. Absolutely. AMS? Goodbye. It demise the… most of the least significant… Absolutely. defines all locations in memory have one represents the most significant bike and the least significant bike. It's equivalent of bike ordering. And… ChatGPT? Gets it right. Mostly. I don't like the way that it includes so open-ended at the bottom here. It says, many modern architectures, such as ARM, support both ND tests. This is a true statement, but it doesn't answer some questions, which is more complicated today, and that matters, because New York, they don't support books. Modern sensors will support a little Indian. And I wanted to observe, before we even behind… to the next chunk of AssetChat GPT, which we'll be getting into today, that ChatGBT, GPT4, GPT5. It can feed back to you factual things, like definitions. That's what we've observed so far. When you ask his engineering questions, It doesn't get them right. Engineering questions like… what's the use of bond mortgage versus arbor? It doesn't fit that right. How often is Little Indian versus Big Endian news? It doesn't get that right. As in careers, your value app is not architecture needs to solve an equation. It is not your capacity to write software. But I mean, like, the programming stuff into advanced box, plenty of attacks. Your value mechanism in nature is your ability to make judgments You're going to say, this isn't the best choice, not this one. That's what you will typically need to do. Everything else can be automated. We've been automating and engineering for a very long time. Decades. We automatically got cap. We are an elective pilot. We automate your calculator? Fantasy software, like, over there. That eliminates tasks that used to be done manually in a system. For instance? But your value add as an engineer is your capacity to make a judgment, Identify trade-offs, and drive completion. And we will continue to see, in addition to getting things back from the end of the records. Judging cannot do that judgment part. It kicks. Because all it does. It's just give you the next most likely word in a sentence based on the process of theory. Which can make it pretty interesting for some applications. It's not great for assisting with engineering. Okay. Before I dive into this, Books, babe? My write-up of the learning outcomes for the first set of lecture notes, they are in the lecture channel in Teams. I have learning outcomes written for every set of lecture notes, except for this one, for some reason, but I need to work on that. I'll post them once they're available. All the other ones, I'm just copying and engaging at this point, but I still need to build out the ones here. The learning outcomes are useful to you, because that's the list of things that I go and look at as I'm writing exams. I try to take off as many of them as I possibly can. So they're a good reference for things that you ought to know, be able to explain to your friends, be able to solve problems about, or whatever. So, learning outcomes for, lecture set number 2 coming soon. So, in this set of lecture notes, we're going to be looking at hardware, Like, exclusively hardware? And we're gonna start with the most fundamental building blocks. transistors, And we're gonna finish. with CPU finite state machines. So, I know for a fact that some of you have already finished Lab 1, which starts today. If you're good at 222, you don't actually need any of this material to do it. Because YouTube is giving you all of the background that you need to build a computer. You've just never been asked to do it before. So, in the next couple of days, I think literally two days, we will go through this set of notes, and you'll be able to do everything that I said. Lab 2. I'm sorry. And we don't need to meet with this stuff to do left one. They're really good with digital logic. Alright. Transistors. Have you seen pictures like this before? This is the cross-sectional view of a transcript. This is not a new transistor, this is an old transistor. New transistors look very different, you can't even describe me, which is a simple cross-sectional view. Yes, have you moved before? Yep. Did you see any 222? Did you just eat for about 5 minutes? Yeah, PS9 switches? Yes. So if you've taken a device physics class, you've seen these two. CMOS transistors are the building blocks of all with the mattress, computers. And they tend to look like this, without generality. They come in two types. The C part of which we bought is complementary. So we have a network that pulls the output up to BDDU, and a complementary network that pulls the output down. Only one of them is going to be active at once. We don't want to be pulling it to BDD in the ground at the same time. That's called short-circuit. But you get a snowboard. And… with hardware. The two devices are basically the same, except for the chemistry. There are 3 terminals, Maybe 4, depending. The three interesting terminals that define its function most very orderly for our purposes are the source, drain, and gate. The gate is like the on-off switch. A typical CMOS player case, Inputs to the circuit, connects to gates. Allow the current flow from the source to the drain. or allowing holes to flow, in the case of P-types, from the source to the drain. So, before being… Make moving charge barriers with the absence of an electronic. You are not responsible for the amount of the exam. This is for your… Thank you. Because every computer engineer, software engineer, electrical engineer should know where computers come from. Your parents will explain it to you already have here to fill in that role. When we draw circuit diagrams, transistors, they tend to look like this. We just have a single, A transistor in each of these cases. For ECMOS transistors, when I have a Positive voltage at the gates. Then the switch is on. The opposite is true, when… for any moths. If positive voltage at the gate for a PMOS, the switch is off. It's an open circuit, no current flows. The simplest logic data of an inverter is over on the left. If age is 1, Or BDD. from a circus perspective, then the NMOS gates, the MLS transistor, is up. Which means that whatever capacitiveness is on the outputs. It's drained away to the grounds. A is 1, out is 0. Lift his wrist. If A is zero, or ground, in that case, the PMOS device connected to VDD is on. A circuit from VDD to the output. The capacitance at the output is charged up to VDD. A is zero, out is 1. Are you with me? I see some… Confused looks on faces, and some not, so… Some of you are with me questions about this. Let's see. and the professor explicitly talked about the topic. One is understanding your history at all. Take these 500-level class. So I'm completely lost. That's true. Excellent. You can understand a statistic with me. Okay. In the bathroom, 5 minutes. As far as computerization. I do frequently see that if you want to really understand how it works, and what Professor Roberts is going to be talking about. Professor Roberts is an analog electronics expert. And, yes. Graduate study, and a belief in magic is required for understanding analog electronics. It's hard. They also… the people that think we make way more money is people that are doing digital atom. So, it pays off. But it's very complicated, and it's all partially differential equation. Where we today, and for this semester, are going to live in the nice, clean, digital world. Don't worry about getting that stuff. That's my gift to you. In the… in the presence of… people that do analog circuits, I think very much be computer scientists. In the presence of computer scientists, I'm very much a computer engineer. So it's all a matter of figuring out more of your comfort. how weird comfort is. But again, They're really just witches. The little button, or the knob on the switch, is the gates. The input that you get is either BDD or grounds. That determines the operation of the device. For our purposes in a nice, clean, visual world, And inverters… Make this very straightforward. When A is 1, out is 0, because if A is 1, then the input to the end loss device on the bottom is 1, and so it's on. We have… we have a closed circuit from out to ground. All of my charge grounds to ground. And so the voltage at out kind of zero. And then the opposite is true in the other case. Sea moss. is always connecting the output to either VDD or friends. every single CMOS case, CMOS therapy is doing one or the other of those things. There are other transistor design libraries that don't do that. We won't talk about those. That's a great subject for a graduate class. Seems sticker. Questions for the burger. Is… The Instinct was A, determining whether the mass would be ends It's opener. If it's booked, then occupied. the value of A determines which of the PMOS or the NMOS devices on, can both be on at the same time, for the context of this class. And whichever, whichever sub-network the pre-moss mint work, or the end moss cement work is on, determines whether or not we have a path from VDD to out. Or… You may not have a tap for heating the ground, that's okay. On the right, we have a NAND case. Same idea. We have our A and B inputs connected to PMOS devices on the top. We have A and B inputs connected to ANOS devices on the bottom. The operation of a NAND gate is not AND, so the output should be 1. In every case except for the case where an AND would have an algorithms 1. That's not panic. So… If I have anything other than A equals 1 and B equals 1, then the output of my NAND gate should be 1. If A equals 1, and B equals 1, then my NMOS circuit is fully activated, and I have a path for knowledge to connect. In every other case, Either A or B is 0. And therefore, have a chat through VDD to house. Jericho does my output to one. With those two transistor-level devices, you can build any computer. And in fact, the first integrated circuit-based computers were built strictly out of Many ways, mentally. It's only more recently, meaning the last 20 or 30 years, that we've done things more complicated. This is also not on the exam. But you can't possibly be the graduate of this department and not have at least a little bit of a transistor-level stuff. In my opinion. No one asked my opinion, but that's my opinion. Now… That's… this is a nice picture for people thinking about physics. This is a nice picture for people thinking about circuits. But how does this actually look when we manufacture it? It looks like that. We do computer engineering circuit design by doing what's called layout. It's a top-down view where we have layers that sit relevant to each other in a stack of materials. That is removed and added and removed and added and removed and added over the course of hundreds of steps in modern manufacturing efforts. In this picture, Metal is blue. And then we have two different places where we have transistors. There's PMOS transdistors in the top, and NMOS transistors in the bottom, and the gates The little bits on the left of our transistors, the gates are indicated by where we have I'm color deficient, and so if I say color that doesn't make sense to you, you have to correct me. That is the social contracts. I'm being vulnerable, and so you have to be willing to say something, so I don't want to embarrass myself, pretty much. I'm gonna say… poly? That kind of looks green to me, but I don't know what it looks like to you. Very, very greedy, thank you, I appreciate that. So, the poly, the vertical strips there, Those are just, like, the… You can think about the connection between the two A's. there's a wired connection there of some kind, an electrical connection. That's that vertical strip for A. Same thing, there's a vertical strip for B that connects the NMOS gates to the PMOS gates, and If I was connecting the inputs there to something previously, I would have blue coming in from the left, and contacting A and B, Kind of like I have, the output there going out to the right. That is what a NAND looks like. We talked a little bit about manufacturing the other day, and about how the problem… that dust can land, and it can make a contact between A and B, or between out and BDD. destroys my circuit. I suddenly have connections where there aren't supposed to be any I used to teach a graduate class on how to do this level of design, and the first homework assignment was to build a processor out of smoke like that. Unfortunately, we don't have anyone here that's teaching that course right now. It's not really my area of research. And I would rather do other things, but… So, look at this picture. Remember this picture? I want to show you what ChatGPT thinks it looks like. I was… So, you know, again… I should be clear. that it delights me to see ChatGPT make mistakes. I, I love it. so much. So, I asked… Draw the layout of a two-input CMOS mandate, including BDD and ground, label signals, and label each layer. If you search just on Google. for two input CMOS mandates, you will find the picture that I used that many others might. It's not like there aren't a lot of these on the internet. So, it gave me two ways of looking at advertising. Sort of an absolute text version, and another more graphical version. What's wrong with both of them? compared to the transition level diagram, and what we were looking at before, what's wrong with both of them? Yeah. box, and it's… Nope. It's the whole process. Yes, who I am. fusion layers, right? That's false. So, yes, I completely agree with you. You could technically take my picture and separate out the individual diffusions for bees and transistors. It's just a really bad idea to do that. It's super inefficient, no one does it that way. There's something else even more egregious. Yes, go ahead. So there's some bad connections here. Remember that the… the PMOS part, yes, each PMOS part was getting E. If either A or B was 0, we wanted to have a connection from B to house. But the NMOS part… A and B were connected to each other, and only the bottom transistor was connected to ground. Whereas we have NMOS looking like a mirror image of CMOS. I have no idea what that circuit is, but this is the most fundamental building block of CMOS. And it's wrong. That's wrong, too, the little stick diagram, and this is just incomprehensible. If you drew this on my exam for ECSE 548, I think that was the one for course number. You were not giving me points. No charge for credit. It is incorrect. Now, there was some of the textual description that went with this, that was maybe a little bit okay, but the visualization doesn't make any sense. So I thought to myself, What if I felt at his block? And say, try again. So I said, the drawing's incorrect. The NMOT devices are supposed to be a series. Poly weights have to cross the entire diffusion. Please add context. And it gives me the same picture of that. No. So, an interesting post on Blue Sky the other day. Most of my Blue Sky feed is timed receivings. And, reactions to the hype stuff, I think that's the hype stuff they might be because it calls it. One thing that someone said I thought was really interesting is that a key defining factor for genetic influence Is our ability to say, I don't know. ChatGPT should have just said it. That's not ridiculous. logically answered. But that's not the nature of the linear algebra. It cannot compute, I don't know. It is impossible for it to come in. which makes ChatGPT Kind of like that person that watches half of a YouTube video, and then talks with great confidence. About whatever the subject matter is. Perhaps you can think of some people in your life that are like that. Oops. We will continue now. Quite little rant over. Okay, no more transition level design. Good luck! This should all be reviewed. So, we can build all sorts of different kinds of gates out of our transistors. The ones that you are most familiar with are here. Surely you've also seen a multiplexer. What's really interesting about, using these block diagrams. Is that… you see a picture like this. And there's lots of different ways to actually build it. Multiplexer. So, if… So… The question is, how many transistors are required to implement this? And what you have to work with are things like NAND gates, Which required 4 transistors. And inverters, which require two. How many transistors are required to build that in the most 2222 kind of a way? How do you build a multiplexer in the 2222 kind of a way? You will have to do stuff like this for Lab 1. Yes. What's your name? Connor. Connor. So we need… so she said two AND gates. How do I make an AND gate? I can't make an AND gate by itself out of transistors. So, in ANDGATE, is a NAND gate plus an inverter, so that's 6. You said two of those… and… And then one inverter. And a coordinator. One inverter, so that's two, and an OR gate. How many transistors do you think it takes to make an ore gauge? I haven't shown you a NOR gate yet. It looks very similar to a NAND gate, though, just slightly rearranged. So we need 6? Okay. So if I want to do… A straightforward implementation of a multiplexer. I can do it in 16 transistors. No one does it this way. If I make a more complex structure. So you, you would know how to draw this, but if I draw a more complex structure, and it looks like this… do, actually, AND or invert, followed by an inverter. I can build this thing with one set of transistors. This is called AND or invert to 2, because I have two inputs there in each of those cases, and I can do that whole thing with 8 transistors plus 2, so this is 10. Compared to 14 here. Or… I can do it in another way, even cheaper, for just $8. This is just to make the point that Every time we move from one part of the design stack to the next, we've got choices how we're gonna implement stuff. Even in my slides here. Even at this level of design, the transistor level design, I have choices. What kind of transistor am I going to use? In 45 nanometers, they only look like what I've shown already. But in 22 nanometers, they don't look that way anymore. You have fintechs, they're 3D specs, instead of just 2D specimens. I wouldn't even know how to draw the ones that, we have at 5 nanometers. In computer organization, we're really concerned with boxes bigger than Pierre than these, but every single time we peer inside of one of the boxes, we have different design choices. Next component, decoder. You give it a… 2-bit input, and you have 4 outs. One hot encoded. Good. Can you think of any places in our major components that we talk about already, say, processor, memory, input, output, where you would need a decoder? Yeah, Charlton. So, if I use a big one of these. And I have a 32-bit address space. How big is that? It's a clear one. Very clean. If I had 4 gigabytes of memory, A is size 32, and I have 4 billion-ish, 4 billion and change, $19 billion. Foot flows. You've dealt with that box. Maybe you've done some gate-level design with a flip box, too. If I want to do a transistor-level implementation of flip-flops, it costs me about 20 transistors. We're gonna be looking at memory soon. And you remember how I was saying that membrane is all about density. We can store one bit of information in memory for way less than 20 transistors. But there are some… Costs associated with that. We don't tend to build stuff out of the flip-flops unless we ask when we need to, because it takes up a lot of space. And you took a lot of power. Space and power, and it's also slow. The most straightforward way to make multi-bit storage would be to string together a bunch of D flip-flops. Here, I've got 4 bits, but this takes me… 80 transistors. Well, we don't store a lot of information that way. What we'd like to do instead Is take advantage of Cross-coupled inverters, essentially. And you can see there, on the right, I only need 4 bits. Sorry, 4 transistors to store a bit in a cross-coupled inverter, plus whatever's required by the box that says Sense Right Circuit, and I don't remember off the top of my head how expensive that is, but it doesn't matter. I will show you again a slide. So, we have 20 bits per… per… 20 transistors per bit here. 4 bits per transistor plus the sense and write logic. We don't want to have sims and write logic for every single one. And this is where the density of memory comes into play. We make arrays of them. So, instead of having… That's… We have something that looks more like… this. Except we would need to extend it out. That way, like that. We're just gonna jump to that. So, we had… 4… Fits in deep blood loss. A transition. Here, I've got 4x4, 16 bits. And I need… For, for every bit cell. Let's do some of our team-based math. 4 is 2 to the 2. for each one, and I've got 16, just 2 and 4. So that's… 2 to the 6th? Which is? 64. 64 transistors. give me… more storage, Then… 4 widths and 80 transistors, if I make it out of the box. But there's actually a complexity here. We've got these word lines and these bit lines in the sense-write circuit. The operation of this now… I give an address, to my 2-bit decoder, It activates a word line. like that. The word line goes the whole width of the array. And then the… each of the individual bit cells. Access transistors, the NF devices next to the bid cells, get turned on. And the bit cell, One output is the complement of the other. Because it's inverters, right? So the input to one of the inverters is going to be 1, the input to the other one is going to be 0, always and forever. So one of the bit lines in each of the cases is connected to a 1, the other one's connected to a 0. I don't have the circuitry here that raises all the bitline values to 1. So all the bid lines are pre-charged for one. then I activate a word line. One of the bit lines in each of the columns is going to then be connected to a zero, and slowly start to discharge a bit line. To ground where the bits are. And that's where the sense of rights have been comes in. We have a lot of capacitance on these long vertical bit lines. And these transistors, I make it as small as I possibly can at their density state, which means that they can't move a lot of currents at once. So you've got a… you've got a big C, And so it takes a long time. The sense right circuit, it doesn't wait for the zero to go all the way down to BD, all the way down to ground. The moment it detects a difference between the bit line 1 and the other one. It basically grabs it and pulls it into the rail. That's where the specific at the bottom does. TLPR… It's a lot more tense. But it's also a lot slower than this. Because it takes more time to charge my word lines. It takes more time to discharge my bit lines, memory. We'll always be slower than flip-flops. But for density, there's no comparison. I saw, and, we're hearing yes in your name. Natasha. Natasha. Step 4 is 30. So each sense-write circuit is associated with a different columns from one computer right. And so, if I give a different address here. What does the address choose among? I have four, four big words here. How are they organized? If I give address 0 versus address 1, what am I choosing versus the other one? You're choosing among the rows. So, because my decoder is 1Hz, there's only ever one output of the decoder, which is 1, all the others could be wrong. The row that is selected is connected to the bits, the bit, lines. And then we see the outputs… we see down at the bottom, whatever the output of the bit cell is for the row that's selected. Do you have another… do you have a follow-up question? Nope. Message me on Teams if you have questions. Ask questions in the lecture channel if you have questions. Yes, in a brief message. What is the cell bit… the bit cell made of? It's that. 200 burgers in seconds. That's the way to do the bit logically. Yes, William. This, good luck. So, what I mean is that… There's hidden electronics here. that allow us to connect both B and B bar to the E. And before I turn on word lines. I… I do that. I connect both B and B bar to BT. Both of them are pre-charged. And then one of them will start to discharge when I activate a fourth line. It'll either be B bar that goes down, or it'll be B that goes down. And it depends on which word line, and it depends on the value that is being saved in the bit cell. Because B can be 1, or B bar can be 1, but they can't both be 1. That's impossible, because they're inverters that are connected output to input to output to input, around and around forever. So… Before I turn on a board line. The bit cells are not connected to the bit hot. Otherwise, I haven't discriminated. Lucy. Understood. the inverters. They're not negative. So… The verter… the inverters are always connected to something. The inverters are always connected, in some way, to both BDD and graft. We have just a little closed feedback. It's, like, feeding back and forth, and switching from zero to one. It's not switching. What is… what is it feeding back? So, if B which is the outputs of the inverter on the right. If… If B is… sorry, no, B is the output of the inverter on the left, and it is connected to the input of the inverter on the right. So if B is 1, That means that… The input to that inverter on the left is zero. which activates the PMOS device, which connects VDD to node B, which makes it a 1. And then the fact that V is a 1 means that the inputs, the inverter on the right, is a 1. which activates the NMOS device. which connects B bar to ground, making V-bar a zero, which is connected to the input of the inverter on the left. And so… It just keeps going. And actually, in the ideal case, nothing is changing. Yeah. Because on the right, B bar is zero. Wired to the ground. And on the left, B is 1, wired to VD. There's no change. Now, in reality. There is always a little bit of current streaking through, because you can't fully turn off these devices, that's called leakage current, not the subject of this class. But we've been having bits being stored. There is no change in the system. It's not combination logic that it's changing at all. You have to change one of the inputs to see it change from in other places in the survey. It's stable. As long as it's connected to BDP in the ground, it's saving. You disconnect it from VED, and you will eventually lose your data. It's volatile. Nick. So, that's this? Does it read? The… What store can not grow and write into the satisfying? So if you're accessing what's stored in… Yes. When you activate a word line. turning on a row. We would call that a read operation, based on what we've described so far. But we'll call this a read operation right now. And the sense-write circuitry is a combination of logic. And what it does is it looks at the two bit lines, and then it produces a single output that corresponding to the value that was stored in the bit cell. And so, if this is a computer memory, you provide an address to a memory location, maybe you get a byte out that the computer then saves someplace else. Make some copy of. We can read from this memory as many times as we want. We don't change the values that are putting in it by reading it. Yes, and your name? If he? Can you select the food? Why is it next level? The advera selects the entire row. So the word line is connected to each of the bit cells in there. For example, an 8-bit, story, I got it, right? I hate to have the same hate dog. updates. April. Exactly. That's right. If I want to have 8-bit storage. Then I need to extend my rows so that they are 8 bits wide. Do you see why it's hard to manipulate a single bit? I can't just write a single bit cell with this architecture. I have to write all 8. or read all 8. So if I want to change a single bit, read all 8 out, do my manipulation, write all 8 back. No shortcut to manipulating a single bit. But that means that's empathically. Bingo. People join me. Goodbye. Yes, exactly. You accomplished, and you may accomplish all the other steps. Because you can't just write one. Yeah. Here's a quote by. Why is the sense right circuit responsible for the whole column? Because that is a lot more area efficient than having a sense-write circuit per bit cell. Because the sense of rate circuit I will find an example of one for next time. But it's been about… 10 years since I saw what they look like, and I don't remember. It's a handful of transitions, it's not a lot. But remember, density is the name of the game here. So we… We collapsed the overhead of the sentence right circuit per itself into having a sentence right circuit per column. It saves us space to pack more bids in for the same number of trends. Me. So, do the fit lines… Since they're on both sides, and then you have, like, the… the B and the Daught. There you go. Like, why is there a Bitcoin on the bullet side? Don't sniffle. So that is a fabulous question. The question is, why is there a good cell on each side? And… the… Short answer… Is that it allows us to make our memory be faster. Because we can then look at… we can do differential signaling. We have one as a reference, and the other one starts to change, and we know that this isn't the one that's supposed to be zero, and we can pull it down? That's what the sense right circuit does? I have to wait for it to go down all the way to about the halfway mark or better, before I started to go all the way down. That's slower. But this is not the only way to design a memory arrays. Remember, this is computer engineering, there are no laws. Here are older values. Which means that I can do… 4-bit… 4 transistor bit cells plus 2 access transistors. We call that a 16-bit cell. There are 17-bit cells. There are 5 2-bit cells. There are two ported membranes that have 4 access transistors. It all depends on the use case, it depends on the manufacturing technology. Sometimes I don't have Two quick lines. There's lots of different ways we build these things. It's all to the purpose that you need it for. Okay. Alright. We will be moving on to this subject very shortly. I want to draw your attention to something. Here, our array is a square. It is 4x4. Now, in general, our memories… The last view of the memory that we've talked about so far is 8 bits wide, Eat? Bytes as its own address, and therefore its own one time coding. Line coming out of the decoder. But… maybe I have… A gigabyte of RAM. That means I have… A billion addresses, each of them, 8-bit spind. Do you think I'd build a memory array by making this 8 bits wide and… 1 billion rows? Not a crazy. We'd all be walking around with our devices with, like, these things, like, shooting out of that because of the memory. I'm not exactly… It doesn't matter how small a thing is, if you're going to stack 4 billion of them on top of each other, it's going to be lost. So, we tend to make memory square. Which makes the architecture a little bit more complicated than this. But the value of things being square has to do with capacitance. Can you tell me why? Why would I want to make my structure square instead of just really, really tall? Space. It does help with space, but that doesn't answer my capacitance question. You're absolutely right, though, about that. Oops. Grace Link, which relates back to the town. Still pain. The longer the trace, the more capacitance. And in a computer circuitry standpoint. In any sort of electronics standpoint, Capacitance means what? Slug. More capacitance, more delay. So I try to balance the length of my board lines and my bit lines. Because I don't have the tendency to optimize their borrowings. I am not served at all by having a short bid line, but a really, really long word line, or vice versa. So we tend to make our memories square. I love it that you all are asking so many questions. We're gonna move on from memory. We think about our picture from last week? we had… Do you have that rating? And then we had our… See you! And the CPU… Yeah. The registry file. ALU. And the inputs to the ALU come from the registered bio. And the output from the ALU goes back to the register file. We load an instruction from memory, we get data from memory, we operate on it here. You've seen the memory part now. We're going to talk about air traffic operations. Muhammad. recycling. Is the size of a memory word the same as the size of the processor word? Got it. Not necessarily. For the purposes of our course, yes. We're not necessarily in general. The processor word might be 32 bits or 64 bits, but the size of what the memory gets back might be different. Definitely different, and it's much larger. Memory work is way larger than a processor work. performance reasons. be better at computer architecture for 25, but we might talk about… talk about memory systems a little more. So you've done… Binary arithmetic, yes? Beautiful. Good. Then I will not belabor this. You… when we do map on unsigned integers, it's very straightforward in binary as well as in decimal. You just take your sequence of bits. And you can do your long addition just the same way that you would before. If I have 8 bits, my smallest number is 0, my largest one is 255, If I happen to do math. That gives me a result larger than the maximum value that I can store, however. We call that overflow. And we see that here, When I add 195 to the 141, I get a number at the bottom, But it is not 336. Now, we didn't do long-hand math, or even calculator math, or MATLAB math. You don't have this problem. It'll give you the right length. You'll get the right answer if you do it by the end. But in computers, We have a computer word size. Maybe it's through Tupas. Let's say it's eats. Let's say that my registered file is made up of 8 big registered. That is the smallest number I can represent in zero, and the largest one I can represent is 255. If I add 195 and 141, Those two numbers are legal. They're inside the valid range, but the result is not. So what I get… is not the right answer. I don't actually know what that number is off the top of my head. But I think it is… So that's 16, it's 32 plus… a hundred and… 28? No. I don't know what that number is, but it's not 336. If I were able to have… if that carry bit. If I have a nice bit, the Gary built, then I can properly represent it, but I can't. Yep, it's chopped off. Now, when I do this math, and I save that number back in my register file, my program is incorrect. That's over. Yes, yes. You just don't pick the right number. You definitely get something. So the question is, do you get an error, or do you just not get the right reader? Computers only ever do exactly what you tell it to. So you will get a number, because your number is just a set of voltages, and remember, we're just dealing with Certainly, dear. Circuitry that just behaves according to the logic index. So we will get… A set of voltages in our register file, corresponding to grounds and VDDs, there will be something there, but if I'm writing a program where I care if there's overflow, then I have to write some software that checks if there was overflow. That's the only way that software really knows that there was a problem. Because the computer is just capacity. So it's useful to be able to detect overflow. To be able to provide a signal to the software that something is happening. So how do we do that? In the case of unsigned arithmetic, I can detect overflow by just checking to see if my carried outfit is a 1. The carryout bit being the carryment of the most significant error in my head. This is a ripple Carry ad? What was the most sophisticated ad in the 222? Did you do a very look ahead? Did you do anything more complicated than that? Sorry? Floating point. You did a floating point. That's not nice. We will talk about holding 100% in this class towards the end of the semester. I'm assuming you'll all get perfect marks on the floating pointer parking. Right. There's gonna be an exam question on the final, until you wonder what you say. I haven't picked the final bit, but I can tell you we're building. So what if we do? Stein to present it? With cytarithmetic, things get a little bit more complicated. In floating point arithmetic, You have a sign bit. Floating point arithmetic is done with floating-point numbers represented with sine. And then you have exponents and mentissa, the instrument capture of magnitude, Signed and magnitude format. I just used, the leftmost bit there, the 8th bit as the sine bit. And then if I want to represent 13 and negative 13, they look like that. They're not different, except for the fact that I've got a sign. We don't do this. There's some reasons why we don't do it. One, we've got two representations for zero. We've got positive zero and negative zero. That might not seem like a big deal, but right people to zero? So I've got two things I need to check instead of just one. For instance, I guess it's relatively straightforward here, just ignore the signed bit, but… And then, if you want to do subtraction, you need, like, a subtractor, which is 4 hardware, which we also don't like. We want to minimize the amount of hardware, so… An alternative is we could do one's compliments. Do we do this? Indigen logic? One compliment? You should not be what's complimented if you're out there. There's no computer that implements one's problematic. You learn about it because it's a stepping stone for a blast. Thank you, you remember something. Alex was not allowed to practice that we remembered something. Every professor is delighted to know that students that after the class remember something. Anything, remember anything. So if we use one small list, we're to get the negative from the positive, just with all the bits. We can do math, and we almost get the right answer. We're just off by one. The fact that we're off by one is what gives us two confidence. To its compliments, when you make a positive number a negative number, all you're doing is just having fun. And that fixes it for us, right? We'll get to that in a second, I guess. For now, though, we've got a problem. With unscient arithmetic, Carry out equals 1 tells us there's overflow. But here, we have overflow when it carried out. But we do not have over the button. We do not have overflow, because the number 2 is representable with the number of bits that we have. We're adding 16, and negative 13, which gives us a number that's closer to zero. It's a representable number. If we have overflow, like in this case. 336 is not representable with 8 bits. Overflow means I can't represent the result. But here I can. So… We need a way to identify when we're having overflow. We use 2's complement in computer arithmetic. When we convert a number into negative 1 for positive fund, we add one. Then when we do our math, We get the right answer. We still have to carry out, but no overflow. You will have to design the circuitry to protect overflow in your CPU for Lab 1. Overflow occurs, In signed arithmetic. If the sign of the output… sorry, the… you have two signs that are the same for your inputs, and the sign for the outcome is different. That's the only situation in which my network. I'm adding two negative numbers, and I get a positive number, I've got two small numbers, and I want to keep getting them to get them smaller and smaller. But then I wrap back around to the top. that's overflow. I was not able to represent My negative number, I got a 5.1%, because I didn't have enough bits. That's overflow. Or if you add two positive numbers. And what you get is a negative number. Means that you didn't have enough bits to represent the size of the positive number. You got a negative 20 instead. This ends up being important for lots of practical applications. Good. Let's say you've taken a picture, I understand that, installing. But it was a little dark. And he wants to adjust the exposure. So you open it up in the photos app, you click edit, and you take that slide in the order exposure, and you slide it to the right. As you slide exposure to the right. The picture goes white, and light with black and white, and then suddenly they just all go black, right? Exactly. Nope. They stay honest. We go to maximum value, And it don't change. If I'm obtaining to emotions. There's lots of signal processing applications for protecting overflow. And currently, the value at the maximum, or at the minimum, is actually a better The other… Okay, what Could complement and make subtraction easy? A minus B is just… B minus A, I should say, it's just B plus minus A. Choose complement means that we can take one adder in our ALU and use it for both addition and subtraction. Which is great. Yes. Shit. Maybe. One way of doing anything. Who cares? You could try it in Lab 1. Okay. I'm gonna draw a picture for you. To illustrate why to relaunch the ALU's… So, in computing, in computer engineering, The number of transistors. It's like the size of Microsoft. The size of my design is the best read across the mind of the sun. more predictors? More cost than any faster. Smaller design, cheaper, bigger designs are more expensive. We talk about manufacturing defects and adjust particles, the bigger it gets, the less likely it gets to work, the more of them I have to take to hit a certain quota. So we want our designs to be as compact as possible, So you've all done… Coding point stuff in 222. If I have a processor, my entire processor is here, Half of it. Here's the point here. Well, Many microcontrollers do not have floating point units because they're enormous. There's the phone! There's not a quantity sheet here that can interpret arbitrary code. It can't do all the instructions that a processor can, but it's huge. So we have a bullet point data path, and then everything else. over here… The rest? His time was left. for exploratory information that I'm working on. registered file, even when all the Acts 3, 2, or 34 registers in it. It's really quite big. Most of the revenue? Here's the ALU. And most of the ALU is the app. Actually, there's one component that I forgot here. Good evening, Jenz? The registered file, most of the rest of it is actually a multiplication. And then you've got everything else in the adder, in ALU, and editions lessons. But multiplication is a whole bunch of… That goes up? Multiplication is added to once, right? That's how you can comment. So I don't want a second adder. I definitely don't want a second amplifier. I want my watch to be as flexible as possible. I want to be able to handle as many different kinds of inputs in one logic hardware as I can. Because I don't want to make my designer, I don't want to make my design slower, so on. Yeah, I guess. One final note here… Is about sign extension. So… The importance of the cure may not yet be obvious. When we talk about… Computer word sizes and memory word sizes, but they're not necessarily the same. I store data into memory, I need to get it out for the computer to process on. In software, we work with bytes, especially in machine learning and single processing. We work with 16 bits, 32 bits, and 4-bits. If my processor… If my processor is… excuse me… I heard it too big of an accessor? And I'm working with bytes, I load a byte from memory, and that's my variable X. Maybe stored in negative, it's negative. The most significant bit is a Latin Bluetooth complement format. I can't just take my… If I'm taking just… 8 bits. And I want to expand that into a 32-bit word. I load 8 bits from memory, and let's say the most significant bit there isn't 1, it's a negative number. How do I ensure that I put a too big number into a negative number? We have to make all of the other ones 1s here. If I grab the most significant bit here, and I fill all the high of this with the most significant bit, then I preserve the number. It's still the same negative number, but importantly, it's negative. If I send it back into memory, I just grab these again. That's fine. I ignore the rest again. But when I'm taking a small number from memory and putting it into a bigger register, I have to do sign extension, otherwise… And it computing. There are all sorts of different places where we do site extension. Because remember from last time, we had that move instruction. Where we moved a small number into the register. And it said that that small number is actually saved in the instruction. I have a 32-bit instruction. Part of it is a small number, it might be negative, and I'm moving it into a bigger register. Anytime I'm moving stuff into registers, I might have to do sign extension in order to not break my negative numbers. You will use sine extension in lap 1, so it cannot bring negative numbers. Because you need negative numbers every single time you do a loop. You want to jump back? Doesn't matter if you're signal processing numbers if it's only working with positive numbers, because you need negative numbers, because you need to take the PC plus PC PC equals 3C plus a negative number. Exactly. We need to be able to do sign extension. 10 minutes. Logical operations. Questions about arithmetic. Yes, go ahead. Well, so… The actual number is still represented. If I've got 10001, In… if I want to know what the positive number that would be, you go… 0111… 1, 0, and I add 1 there. So that's, 127. So, this number is negative 127. If I put a whole bunch of ones out here, it's still negative 127. I haven't changed it. But I'm not sure that answered the question or not. Oh, Thank you, Muhammad, for answering this question. Other questions? Okay, logical operations? Way more straightforward. You'll find this in Lab 1 as well. Our processors can do things like AD, but also AND and OR. The question of how do I change a single bit has come up. Well, the way that you change a single bit is you load a value from memory. You can perform an AND or an OR, depending upon what you're going for, with a mass. To modify the antibodies for memory, and then you write it back. So, Bitwise and Bitwise 4 allow you to do bit-level manipulations of… large number of numbers. Numbers anymore at that point, but they're variables of some kind. And to do a bitwise AND and OR, you just take… you just have an AND or an OR gates for each bit position you have. Take the least significant bits, the next, the next, the next, the next, the next, and you just perform a logical operation. The easiest part of that fund is the… basic Boolean operators. Except for 500 ADX. I'm sorry, but do not have break the HDL. So there you go. Bitwise Hand. Shifting operations. If I have… 8 bits. And each bit represented something different. I've got a bit better that represents attendance in this class. There would be a fair number of deer raggles. Because every seat is supposed to be filled. If I want to know if some particular position is a 0 or a 1, then one way to do that is to shift. I can take some bit position in the middle of a field, and I can shift it all the way to the right. I can hand it with zeros in every other bit position to 0 or 1 in the least significant position. That tells me the value of that one bit. So my computer can do a Shijing. I can logical shift left, I can logical shift right. That just takes the bits and moves them, and sort of fills in zeros in any big slots. Or I can do an arithmetic shift right. What the arithmetic part of arithmetic shift right means is I do sign extension. So if I had a negative number. And I'm sticking it to the rice. feeling more blind, otherwise I change it from a negative number to a positive number. Yes, indeed. Yeah. That's all the pros games. And yes. is an instructor in the arm insertion set. It's like 15, but it's not destructive. Whenever… you can rotate to the right, you can rotate to the left. Whenever a bit falls off, this gets put in on the other side. Sometimes we can use spin operations to do math. Because if I shift to the left, And multiplying by 2. Just like when decimal by hitting the numbers to the left and multiplying by 10. If I shift to the right, I'm performing the Bish interval. Roughly, If it doesn't divide evenly, you lose the remainder. But you can divide by 2 by tweaking things to the right. You were introduced to… Slow occasion. We built shifters where on each clock cycle, they can move a bit of a single position. But if I want 32-bit or 64-bit numbers, I want to ship them 15, 20, 8 times. I've been waiting an awfully long time for the operation to complete. You can do it in a single step. And you just use a bunch of muxes with your app. So, this example, Shows 4 inputs. And I can shift… to the left by… I can shift, left by 1, by 2, or by 3 positions. It just takes 8 muscles and some wiring. The wiring, it turns out, is the most expensive of parts of doing a barrel shooter. If I were to expand this to a 64-bit input, where I can ship up to 63 positions. It's a mess. And computer engineers have come up with clever ways of trying to manage that mess, but the wiring… I was talking about area, often you want the area to be dominated by transistors. But in circuits like this, it's not painted by wires. Let's see… I'm skipping the exercises, trusting that you can do them on your own. And that allows me to answer your questions in class. But I'm gonna check real quick to see how far I'm supposed to get in this. I think we might be just about… But, we'll see. Where's my schedule? Let's see… 37. Oh. Where are we? Oh, we didn't get… yeah. We are a little bit behind, that's okay. I am going to stop here and see you on Monday. Lap 1 starts today!

Seek back 10 seconds

Pause

Seek forward 30 seconds

Mute
Current Time 
0:34
/
Duration 
1:16:07
 
1x
Playback Rate

Captions

Fullscreen

Picture-in-Picture
